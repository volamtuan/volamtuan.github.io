<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Qu·∫£n l√Ω t√†i kho·∫£n theo domain</title>
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  />
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      padding: 20px;
    }
    textarea,
    input[type='file'] {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      border-radius: 4px;
      border: 1px solid #ccc;
      resize: vertical;
    }

    /* B·∫£ng domain scroll & c·ªë ƒë·ªãnh header */
    #domainTable {
      display: block;
      max-height: 320px;
      overflow-y: auto;
      border-collapse: separate;
      border-spacing: 0;
    }
    #domainTable thead,
    #domainTable tbody {
      display: block;
    }
    #domainTable tbody {
      max-height: 280px;
      overflow-y: auto;
    }
    #domainTable thead tr {
      display: table;
      width: 100%;
      table-layout: fixed;
    }
    #domainTable tbody tr {
      display: table;
      width: 100%;
      table-layout: fixed;
      user-select: none;
      cursor: pointer;
    }
    #domainTable tbody tr:hover {
      background-color: #f1f8ff;
    }
    #domainTable tbody tr.selected {
      background-color: #c3ddff !important;
    }
    .copy-btn {
      background-color: #17a2b8;
      border: none;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
    }
    #copyMessage {
      color: green;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s ease;
      margin-left: 10px;
    }
    #accountList {
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <h3 class="mb-4">üìã Qu·∫£n l√Ω t√†i kho·∫£n theo domain</h3>

    <textarea
      id="manualInput"
      rows="6"
      placeholder="D√°n d·ªØ li·ªáu v√†o ƒë√¢y. M·ªói t√†i kho·∫£n m·ªôt d√≤ng."
    ></textarea>
    <button class="btn btn-success mb-3" onclick="processManualInput()">X·ª≠ l√Ω th·ªß c√¥ng</button>
    
    <input type="file" id="fileInput" multiple accept=".txt,.zip" />

    <hr />
    <div class="mb-3">
      <button class="btn btn-primary" id="copyAllDomainsBtn">Copy t·∫•t c·∫£ t√†i kho·∫£n (t·∫•t c·∫£ domain)</button>
      <span id="copyAllDomainsMsg" style="color: green; font-weight: 600; opacity: 0; margin-left: 10px; transition: opacity 0.3s ease;">‚úÖ ƒê√£ copy!</span>
    </div>
    <h4>üìö Danh s√°ch domain</h4>
    <div class="form-group">
      <input
        type="text"
        id="searchDomainInput"
        class="form-control"
        placeholder="T√¨m domain..."
        oninput="filterDomainTable()"
        autocomplete="off"
      />
    </div>
    <table id="domainTable" class="table table-bordered table-hover" aria-label="B·∫£ng th·ªëng k√™ domain">
      <thead class="thead-light">
        <tr>
          <th>Domain</th>
          <th>S·ªë t√†i kho·∫£n</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div id="accountListBox" style="display: none;">
      <h4 class="mt-4">
        üìú T√†i kho·∫£n trong domain: <span id="selectedDomain"></span>
        <button class="btn btn-warning btn-sm ml-3" id="copyAllButton" onclick="copyAllAccounts()">Copy t·∫•t c·∫£</button>
        <span id="copyMessage">‚úÖ ƒê√£ copy!</span>
      </h4>

      <div id="accountList"><!-- danh s√°ch t√†i kho·∫£n s·∫Ω hi·ªán ·ªü ƒë√¢y --></div>
    </div>
  </div>

  <script>
    const domainAccounts = new Map();

    // Ph√¢n t√≠ch 1 d√≤ng
    function parseAccount(line) {
      if (!line) return null;

      // D·∫°ng user|pass
      const parts = line.trim().split("|");
      if (parts.length >= 2 && parts[0].includes("@")) {
        const user = parts[0];
        const pass = parts[1];
        const domain = user.split("@")[1].toLowerCase();
        return { user, pass, domain };
      }

      // D√≤ng li·ªÅn: URL: ... Username: ... Password: ...
      const blockMatchURL = line.match(/URL:\s*(.*?)\s*Username:\s*(.*?)\s*Password:\s*(.*)/i);
      if (blockMatchURL) {
        try {
          const domain = new URL(blockMatchURL[1].trim()).hostname.toLowerCase();
          const user = blockMatchURL[2].trim();
          const pass = blockMatchURL[3].trim();
          return { user, pass, domain };
        } catch {
          return null;
        }
      }

      // D√≤ng li·ªÅn: Host: ... Login: ... Password: ...
      const blockMatchHost = line.match(/Host:\s*(\S+)\s*Login:\s*(\S+)\s*Password:\s*(.*)/i);
      if (blockMatchHost) {
        try {
          const domain = new URL(blockMatchHost[1].trim()).hostname.toLowerCase();
          const user = blockMatchHost[2].trim();
          const pass = blockMatchHost[3].trim();
          return { user, pass, domain };
        } catch {
          return null;
        }
      }

      return null;
    }

    // X·ª≠ l√Ω block nhi·ªÅu d√≤ng d·∫°ng URL, Username, Password
    function processMultiLineAccounts(text) {
      const lines = text.split(/\r?\n/);
      const results = [];

      for (let i = 0; i < lines.length; i++) {
        const urlLine = lines[i].trim();
        if (urlLine.toLowerCase().startsWith("url:") && i + 2 < lines.length) {
          const userLine = lines[i + 1].trim();
          const passLine = lines[i + 2].trim();

          // H·ªó tr·ª£ Username/User, Password/Pass
          const userPrefix = userLine.match(/^username:/i)
            ? "username:"
            : userLine.match(/^user:/i)
            ? "user:"
            : null;
          const passPrefix = passLine.match(/^password:/i)
            ? "password:"
            : passLine.match(/^pass:/i)
            ? "pass:"
            : null;

          if (userPrefix && passPrefix) {
            try {
              const url = urlLine.substring(4).trim();
              const domain = new URL(url).hostname.toLowerCase();
              const user = userLine.substring(userPrefix.length).trim();
              const pass = passLine.substring(passPrefix.length).trim();
              results.push({ user, pass, domain });
              i += 2;
            } catch {}
          }
        }
      }
      return results;
    }

    // X·ª≠ l√Ω block nhi·ªÅu d√≤ng d·∫°ng Soft, Host, Login, Password
    function processSoftBlockAccounts(text) {
      const lines = text.split(/\r?\n/);
      const results = [];

      for (let i = 0; i < lines.length; i++) {
        if (lines[i].toLowerCase().startsWith("soft:")) {
          if (i + 3 < lines.length) {
            const hostLine = lines[i + 1].trim();
            const loginLine = lines[i + 2].trim();
            const passLine = lines[i + 3].trim();

            const hostMatch = hostLine.match(/^Host:\s*(.+)$/i);
            const loginMatch = loginLine.match(/^Login:\s*(.+)$/i);
            const passMatch = passLine.match(/^Password:\s*(.+)$/i);

            if (hostMatch && loginMatch && passMatch) {
              try {
                const domain = new URL(hostMatch[1].trim()).hostname.toLowerCase();
                const user = loginMatch[1].trim();
                const pass = passMatch[1].trim();
                results.push({ user, pass, domain });
                i += 3;
              } catch {}
            }
          }
        }
      }
      return results;
    }

    // Th√™m t√†i kho·∫£n v√†o domainAccounts, tr√°nh tr√πng
    function addAccount({ user, pass, domain }) {
      if (!domain) return;
      if (!domainAccounts.has(domain)) domainAccounts.set(domain, []);
      const list = domainAccounts.get(domain);
      if (!list.some(acc => acc.user === user && acc.pass === pass)) {
        list.push({ user, pass });
      }
    }

    // X·ª≠ l√Ω to√†n b·ªô text
    function processLines(text) {
      // D√≤ng ƒë∆°n l·∫ª
      for (const line of text.split(/\r?\n/)) {
        const acc = parseAccount(line);
        if (acc) addAccount(acc);
      }
      // Block nhi·ªÅu d√≤ng URL/Username/Password
      const multi = processMultiLineAccounts(text);
      for (const acc of multi) addAccount(acc);

      // Block Soft/Host/Login/Password
      const softBlock = processSoftBlockAccounts(text);
      for (const acc of softBlock) addAccount(acc);
    }

    // X·ª≠ l√Ω textarea th·ªß c√¥ng
    function processManualInput() {
      const content = document.getElementById("manualInput").value;
      if (!content.trim()) return alert("B·∫°n ch∆∞a nh·∫≠p d·ªØ li·ªáu.");
      domainAccounts.clear();
      processLines(content);
      updateDomainTable();
      document.getElementById("accountListBox").style.display = "none";
    }

    // ƒê·ªçc file txt
    function readTxtFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          processLines(e.target.result);
          resolve();
        };
        reader.onerror = e => reject(e);
        reader.readAsText(file);
      });
    }

    // ƒê·ªçc file zip v·ªõi JSZip, l·∫•y file .txt c√≥ d·ªØ li·ªáu h·ª£p l·ªá
    async function readZipFile(file) {
      const zip = await JSZip.loadAsync(file);
      const entries = Object.values(zip.files);
      for (const entry of entries) {
        if (!entry.name.toLowerCase().endsWith(".txt")) continue;

        const content = await entry.async("string");
        // Ki·ªÉm tra nhanh file n√†y c√≥ d√≤ng parse ƒë∆∞·ª£c kh√¥ng
        const lines = content.split(/\r?\n/);
        const hasValidLine =
          lines.some(line => parseAccount(line) !== null) ||
          processMultiLineAccounts(content).length > 0 ||
          processSoftBlockAccounts(content).length > 0;
        if (!hasValidLine) continue;

        processLines(content);
      }
    }

    // X·ª≠ l√Ω ch·ªçn nhi·ªÅu file
    document.getElementById("fileInput").addEventListener("change", async function () {
      if (!this.files.length) return;
      domainAccounts.clear();

      const files = [...this.files];
      const tasks = files.map(file => {
        if (file.name.toLowerCase().endsWith(".txt")) {
          return readTxtFile(file);
        } else if (file.name.toLowerCase().endsWith(".zip")) {
          return readZipFile(file);
        } else {
          return Promise.resolve();
        }
      });

      try {
        await Promise.all(tasks);
        updateDomainTable();
        document.getElementById("accountListBox").style.display = "none";
      } catch (e) {
        alert("L·ªói khi ƒë·ªçc file: " + e.message);
      }
    });

    // C·∫≠p nh·∫≠t b·∫£ng domain
    function updateDomainTable() {
      const tbody = document.querySelector("#domainTable tbody");
      tbody.innerHTML = "";
      const sorted = [...domainAccounts.entries()].sort((a, b) => b[1].length - a[1].length);
      for (const [domain, accounts] of sorted) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${domain}</td><td>${accounts.length}</td>`;
        tbody.appendChild(tr);
      }
      initMultiSelect(document.querySelector("#domainTable tbody"));
    }

    // K√©o ch·ªçn nhi·ªÅu d√≤ng v·ªõi t·ªëi ƒëa 10 d√≤ng
    function initMultiSelect(tbody) {
      let isMouseDown = false;
      let startIndex = null;
      const MAX_SELECT = 20;

      function clearSelection() {
        tbody.querySelectorAll("tr.selected").forEach(tr => tr.classList.remove("selected"));
      }

      function selectRange(start, end) {
        clearSelection();
        const rows = tbody.children;
        let from = Math.min(start, end);
        let to = Math.max(start, end);

        if (to - from + 1 > MAX_SELECT) {
          if (start < end) {
            to = from + MAX_SELECT - 1;
          } else {
            from = to - MAX_SELECT + 1;
            if (from < 0) from = 0;
          }
        }

        for (let i = from; i <= to && i < rows.length; i++) {
          rows[i].classList.add("selected");
        }
      }

      tbody.onmousedown = e => {
        if (e.target.tagName !== "TD") return;
        e.preventDefault();
        isMouseDown = true;
        const tr = e.target.closest("tr");
        if (!tr) return;
        startIndex = Array.from(tbody.children).indexOf(tr);
        selectRange(startIndex, startIndex);
      };

      tbody.onmouseover = e => {
        if (!isMouseDown) return;
        if (e.target.tagName !== "TD") return;
        const tr = e.target.closest("tr");
        if (!tr) return;
        const currentIndex = Array.from(tbody.children).indexOf(tr);
        selectRange(startIndex, currentIndex);
      };

      document.addEventListener("mouseup", () => {
        if (isMouseDown) {
          isMouseDown = false;
          // X·ª≠ l√Ω khi k·∫øt th√∫c k√©o ch·ªçn (n·∫øu c·∫ßn)
        }
      });

      // Click 1 d√≤ng ƒë·ªÉ hi·ªán t√†i kho·∫£n t∆∞∆°ng ·ª©ng
      tbody.querySelectorAll("tr").forEach(tr => {
        tr.onclick = () => {
          const domain = tr.cells[0].textContent;
          showAccounts(domain);
        };
      });
    }

    // Hi·ªÉn th·ªã t√†i kho·∫£n theo domain
    function showAccounts(domain) {
      const container = document.getElementById("accountList");
      container.innerHTML = "";
      const accounts = domainAccounts.get(domain) || [];

      accounts.forEach(({ user, pass }) => {
        const item = document.createElement("div");
        item.style.display = "flex";
        item.style.justifyContent = "space-between";
        item.style.alignItems = "center";
        item.style.padding = "4px 0";
        item.style.borderBottom = "1px solid #eee";

        const textSpan = document.createElement("span");
        textSpan.textContent = `${user}|${pass}`;

        const btn = document.createElement("button");
        btn.textContent = "Copy";
        btn.className = "copy-btn";
        btn.style.flexShrink = "0";
        btn.onclick = e => {
          e.stopPropagation();
          navigator.clipboard.writeText(`${user}|${pass}`).then(() => {
            alert(`‚úÖ ƒê√£ copy: ${user}|${pass}`);
          });
        };

        item.appendChild(textSpan);
        item.appendChild(btn);
        container.appendChild(item);
      });

      document.getElementById("selectedDomain").textContent = domain;
      document.getElementById("accountListBox").style.display = "block";
    }

    // Copy to√†n b·ªô t√†i kho·∫£n domain hi·ªán t·∫°i
    function copyAllAccounts() {
      const domain = document.getElementById("selectedDomain").textContent;
      const accounts = domainAccounts.get(domain);
      if (!accounts?.length) return alert("Kh√¥ng c√≥ t√†i kho·∫£n.");
      const content = accounts.map(acc => `${acc.user}|${acc.pass}`).join("\n");
      navigator.clipboard.writeText(content).then(() => {
        const msg = document.getElementById("copyMessage");
        msg.style.opacity = 1;
        setTimeout(() => (msg.style.opacity = 0), 1500);
      });
    }

    // Copy t·∫•t c·∫£ t√†i kho·∫£n t·∫•t c·∫£ domain theo format domain|user|pass
    document.getElementById("copyAllDomainsBtn").addEventListener("click", () => {
      if (domainAccounts.size === 0) {
        alert("Ch∆∞a c√≥ t√†i kho·∫£n n√†o.");
        return;
      }

      const allEntries = new Set();

      domainAccounts.forEach((accounts, domain) => {
        for (const acc of accounts) {
          const entry = `${domain}|${acc.user}|${acc.pass}`;
          allEntries.add(entry);
        }
      });

      if (allEntries.size === 0) {
        alert("Ch∆∞a c√≥ t√†i kho·∫£n n√†o.");
        return;
      }

      const content = [...allEntries].join("\n");
      navigator.clipboard.writeText(content).then(() => {
        const msg = document.getElementById("copyAllDomainsMsg");
        msg.style.opacity = 1;
        setTimeout(() => {
          msg.style.opacity = 0;
        }, 1500);
      });
    });

    // L·ªçc domain b·∫£ng
    function filterDomainTable() {
      const filter = document.getElementById("searchDomainInput").value.toLowerCase();
      const tbody = document.querySelector("#domainTable tbody");
      const rows = tbody.querySelectorAll("tr");

      rows.forEach(row => {
        const domainCell = row.cells[0].textContent.toLowerCase();
        row.style.display = domainCell.includes(filter) ? "" : "none";
      });
    }
  </script>
</body>
</html>
